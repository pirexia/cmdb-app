<?php
// run_notifications.php
// Script para ser ejecutado por un cron job para enviar notificaciones.

// Importaciones necesarias para las clases utilizadas en el script CLI
use Dotenv\Dotenv;
use App\Models\Asset;
use App\Models\Contract;
use App\Services\MailService;
use App\Services\NotificationService;
use PHPMailer\PHPMailer\PHPMailer;
use League\Plates\Engine as PlatesEngine;
use Monolog\Logger;
use Monolog\Handler\StreamHandler;
use Monolog\Formatter\LineFormatter;
use Psr\Log\LoggerInterface;

require __DIR__ . '/vendor/autoload.php';

// Cargar las variables de entorno
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

// Cargar la configuración de la aplicación
$appConfig = require __DIR__ . '/app/Config/config.php';

// Inicializar el contenedor de inyección de dependencias (PHP-DI)
$container = new \DI\Container();

// === Definir servicios necesarios de forma que LoggerInterface se instancie directamente ===

// Configuración del Logger (Monolog) - Instancia CONCRETA de Monolog\Logger
$cliLogger = new Logger('CMDB_CLI_App'); // <--- Instanciamos directamente Monolog\Logger
$logPath = $appConfig['paths']['logs'] . '/app_cli.log'; // Log CLI separado
$logLevel = $appConfig['app']['env'] === 'development' ? Logger::DEBUG : Logger::INFO;
$formatter = new LineFormatter("[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n", "Y-m-d H:i:s", true, true);
$streamHandler = new StreamHandler($logPath, $logLevel);
$streamHandler->setFormatter($formatter);
$cliLogger->pushHandler($streamHandler);

// Pasamos el logger CONCRETO al contenedor
$container->set(LoggerInterface::class, $cliLogger); // <--- Mapeamos la interfaz al objeto CONCRETO
$container->set('logger', $cliLogger); // También por el nombre 'logger'

// Configuración de la base de datos (PDO)
$container->set('db', function (\Psr\Container\ContainerInterface $c) use ($appConfig) {
    $dbConfig = $appConfig['db'];
    $dsn = "mysql:host={$dbConfig['host']};dbname={$dbConfig['name']};charset={$dbConfig['charset']}";
    $options = [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC, PDO::ATTR_EMULATE_PREPARES => false];
    return new PDO($dsn, $dbConfig['user'], $dbConfig['pass'], $options);
});

// Configuración de PlatesEngine para plantillas de correo
$container->set(PlatesEngine::class, function (\Psr\Container\ContainerInterface $c) use ($appConfig) {
    $viewsPath = $appConfig['paths']['views'];
    $engine = new PlatesEngine($viewsPath);
    $engine->addFolder('emails', $viewsPath . '/emails');
    return $engine;
});

// Configuración de PHPMailer - Ahora recibe el LoggerInterface del contenedor
$container->set('mailer', function (\Psr\Container\ContainerInterface $c) use ($appConfig) {
    $smtpConfig = $appConfig['smtp'];
    $mail = new PHPMailer(true);
    try {
        $mail->isSMTP();
        $mail->Host       = $smtpConfig['host'];
        $mail->Port       = $smtpConfig['port'];
        $mail->CharSet    = 'UTF-8';
        $mail->SMTPAuth   = $smtpConfig['auth_required'];
        if ($smtpConfig['auth_required']) { $mail->Username = $smtpConfig['username']; $mail->Password = $smtpConfig['password']; }
        if (!empty($smtpConfig['encryption'])) {
            $mail->SMTPSecure = match ($smtpConfig['encryption']) {
                'tls' => PHPMailer::ENCRYPTION_STARTTLS,
                'ssl' => PHPMailer::ENCRYPTION_SMTPS,
                default => false,
            };
        } else { $mail->SMTPSecure = false; }
        $mail->SMTPOptions = ['ssl' => ['verify_peer' => false, 'verify_peer_name' => false, 'allow_self_signed' => true]];
        $mail->setFrom($smtpConfig['from_email'], $smtpConfig['from_name']);
        return $mail;
    } catch (Throwable $e) {
        // Usa el logger obtenido del contenedor
        $c->get(LoggerInterface::class)->error("Error al configurar PHPMailer en CLI: {$e->getMessage()}");
        return null;
    }
});

// Pasamos $appConfig directamente a su constructor, ya que no tiene una definición 'config' en el contenedor CLI
$container->set(App\Services\MailService::class, function (\Psr\Container\ContainerInterface $c) use ($appConfig) { // <-- Usamos $appConfig aquí
    return new App\Services\MailService(
        $c->get('mailer'),
        $c->get(Psr\Log\LoggerInterface::class), // El logger ya se resolvió bien
        $c->get(League\Plates\Engine::class),
        $appConfig // <--- ¡CAMBIO CLAVE AQUÍ! Pasamos el array $appConfig directamente
    );
});

// Definiciones de Modelos (para NotificationService)
$container->set(Asset::class, function (\Psr\Container\ContainerInterface $c) { return new Asset($c->get('db')); });
$container->set(Contract::class, function (\Psr\Container\ContainerInterface $c) { return new Contract($c->get('db')); });

// === INSTANCIA DE NotificationService ===
// Obtenemos las dependencias del contenedor y pasamos $appConfig directamente
$assetModel = $container->get(Asset::class);
$contractModel = $container->get(Contract::class);
$mailService = $container->get(MailService::class); // MailService ya está en el contenedor
$logger = $container->get(LoggerInterface::class); // <--- Obtenemos la instancia concreta de LoggerInterface

$notificationService = new NotificationService(
    $assetModel,
    $contractModel,
    $mailService,
    $logger, // Pasamos el logger resuelto por el contenedor
    $appConfig
);

$logger->info("Cron Job: Ejecutando notificaciones de caducidad.");

try {
    $notificationService->sendExpirationNotifications();
    $logger->info("Cron Job: Proceso de notificaciones finalizado.");
} catch (Throwable $e) {
    $logger->critical("Cron Job: Error crítico en las notificaciones: " . $e->getMessage() . " - " . $e->getTraceAsString());
}
?>
